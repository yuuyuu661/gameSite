<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ブロックブラスト | ミニゲーム</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

  <link rel="stylesheet" href="/style.css"/>

  <style>
    :root {
      color-scheme: dark;
      --bg: #050510;
      --card: #101522;
      --accent: #4fd1c5;
      --accent-soft: #285e61;
      --danger: #f56565;
      --grid-cell: #1a2335;
      --grid-filled: #63b3ed;
      --grid-filled-2: #f6e05e;
      --text: #f7fafc;
      --muted: #a0aec0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background: radial-gradient(circle at top, #1a365d 0, #050510 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 12px;
    }
    .wrapper {
      max-width: 960px;
      width: 100%;
      margin: auto;
    }
    .header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 8px;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0;
    }
    .subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--text);
      font-size: 0.75rem;
      white-space: nowrap;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 20px 40px #0009;
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .board-card { flex: 1 1 260px; }
    .side-card { flex: 1 1 260px; }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .stat {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 0.8rem;
      min-width: 90px;
    }
    .stat-label { color: var(--muted); }
    .stat-value { font-weight: 600; font-size: 0.95rem; }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 3px;
      background: #020617;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid #1e293b;
      touch-action: none;
    }
    .cell {
      width: 100%;
      aspect-ratio: 1/1;
      border-radius: 6px;
      background: radial-gradient(circle at top, #1f2937, #020617);
      border: 1px solid #111827;
      cursor: pointer;
      transition: transform 0.05s, background 0.1s, box-shadow 0.1s, outline 0.05s;
    }
    .cell.filled {
      background: linear-gradient(135deg, var(--grid-filled), var(--grid-filled-2));
      box-shadow: 0 0 8px #63b3edaa;
    }
    .cell.highlight {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
      box-shadow: 0 0 10px #4fd1c588;
    }
    .cell.invalid {
      outline: 2px solid var(--danger);
      outline-offset: -2px;
    }
    .cell:active {
      transform: scale(0.96);
    }

    .pieces-container {
      margin-top: 10px;
    }
    .pieces-title {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pieces {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .piece {
      background: #020617;
      border-radius: 10px;
      padding: 6px;
      border: 1px solid #1f2937;
      cursor: grab;
      transition: transform 0.08s, box-shadow 0.08s, border-color 0.08s, opacity 0.08s;
      touch-action: none;
    }
    .piece:active {
      cursor: grabbing;
    }
    .piece.disabled {
      opacity: 0.25;
      cursor: default;
    }
    .piece.selected {
      border-color: var(--accent);
      box-shadow: 0 0 10px #4fd1c588;
      transform: translateY(-2px);
    }
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      opacity: 0.95;
    }
    .drag-ghost .piece-grid {
      transform: scale(1.15);
    }

    .piece-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 2px;
    }
    .p-cell {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      background: transparent;
    }
    .p-cell.filled {
      background: linear-gradient(135deg, var(--grid-filled), var(--grid-filled-2));
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 10px;
      font-size: 0.8rem;
      color: var(--muted);
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 6px 14px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--accent-soft);
      color: #e6fffa;
      box-shadow: 0 8px 18px #0007;
      transition: transform 0.05s, box-shadow 0.05s, background 0.1s;
    }
    button:hover {
      background: var(--accent);
      box-shadow: 0 10px 22px #0009;
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 4px 10px #0008;
    }

    .log {
      font-size: 0.78rem;
      color: var(--muted);
      margin-top: 8px;
      max-height: 120px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .log-line { margin-bottom: 2px; }
    .log-line strong { color: var(--accent); }

    @media (max-width: 640px) {
      .card { padding: 10px; }
      .piece-grid .p-cell {
        width: 12px;
        height: 12px;
      }
    }
  </style>

  <script>
    // ダブルタップ拡大防止（スマホ用）
    let __lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - __lastTouchEnd <= 300) {
        e.preventDefault();
      }
      __lastTouchEnd = now;
    }, { passive: false });
  </script>
</head>
<body>
  <!-- 効果音ファイル（同じフォルダに置く） -->
  <audio id="seMove" src="move.mp3" preload="auto"></audio>
  <audio id="se1" src="1lane.mp3" preload="auto"></audio>
  <audio id="se2" src="2lane.mp3" preload="auto"></audio>
  <audio id="se3" src="3lane.mp3" preload="auto"></audio>
  <audio id="seGameover" src="gameover.mp3" preload="auto"></audio>

  <div class="wrapper">
    <div class="header">
      <div>
        <h1>ブロックブラスト</h1>
        <div class="subtitle">block / 8×8 ブロックパズル</div>
      </div>
      <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
        <a class="game" href="/">← メニューへ</a>
        <span class="badge">ドラッグで配置・ラインを揃えてスコアアップ</span>
      </div>
    </div>

    <div class="row">
      <div class="card board-card">
        <div class="stats">
          <div class="stat">
            <span class="stat-label">スコア</span>
            <span class="stat-value" id="score">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">直近コンボ(同時ライン)</span>
            <span class="stat-value" id="combo">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">最大コンボ</span>
            <span class="stat-value" id="maxCombo">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">置いたブロック数</span>
            <span class="stat-value" id="blocksPlaced">0</span>
          </div>
        </div>

        <div class="board" id="board"></div>

        <div class="pieces-container">
          <div class="pieces-title">
            <span>ブロック候補（3つセット）</span>
            <span id="turnInfo" class="badge">新しいセット</span>
          </div>
          <div class="pieces" id="pieces"></div>
        </div>

        <div class="controls">
          <button id="newGame">リセット</button>
          <span id="statusText">
            ブロックをドラッグして、盤面にドロップしてください。（タップ置きも可）
          </span>
        </div>
      </div>

      <div class="card side-card">
        <h3 style="margin:0 0 6px;font-size:1rem;">プレイログ</h3>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { submitScore } from "/js/common.js";
const BOARD_SIZE = 8;

    const SHAPES = [
      { name: "1",   cells: [[0,0]] },
      { name: "2h", cells: [[0,0],[1,0]] },
      { name: "2v", cells: [[0,0],[0,1]] },
      { name: "3h", cells: [[0,0],[1,0],[2,0]] },
      { name: "3v", cells: [[0,0],[0,1],[0,2]] },
      { name: "4h", cells: [[0,0],[1,0],[2,0],[3,0]] },
      { name: "4v", cells: [[0,0],[0,1],[0,2],[0,3]] },
      { name: "2x2", cells: [[0,0],[1,0],[0,1],[1,1]] },
      { name: "L3a", cells: [[0,0],[0,1],[1,1]] },
      { name: "L3b", cells: [[1,0],[1,1],[0,1]] },
      { name: "L3c", cells: [[0,0],[1,0],[1,1]] },
      { name: "L3d", cells: [[0,1],[1,1],[1,0]] },
      { name: "L4a", cells: [[0,0],[0,1],[0,2],[1,2]] },
      { name: "L4b", cells: [[1,0],[1,1],[1,2],[0,2]] },
      { name: "L4c", cells: [[0,0],[1,0],[1,1],[1,2]] },
      { name: "L4d", cells: [[0,0],[0,1],[0,2],[1,0]] },
      { name: "T5h", cells: [[0,0],[1,0],[2,0],[1,1],[1,2]] },
      { name: "T5v", cells: [[1,0],[0,1],[1,1],[2,1],[1,2]] },
      { name: "3x2", cells: [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]] },
      { name: "5h",  cells: [[0,0],[1,0],[2,0],[3,0],[4,0]] },
      { name: "5v",  cells: [[0,0],[0,1],[0,2],[0,3],[0,4]] },
    ];

    let board = [];
    let score = 0;
    let currentCombo = 0;
    let maxCombo = 0;
    let blocksPlaced = 0;
    let pieces = [];
    let selectedPieceIndex = null;
    let gameOver = false;
    let dragGhostEl = null;

    // ドラッグ状態
    let isDragging = false;
    let dragPieceIndex = null;
    let hoverX = null;
    let hoverY = null;

    // DOM
    let logEl, boardEl, piecesEl, scoreEl, comboEl, maxComboEl, blocksPlacedEl, statusEl, turnInfoEl;
    let seMove, se1, se2, se3, seGameover;

    function log(msg) {
      const line = document.createElement("div");
      line.className = "log-line";
      line.innerHTML = msg;
      logEl.prepend(line);
    }

    function initBoard() {
      board = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        const row = new Array(BOARD_SIZE).fill(0);
        board.push(row);
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const div = document.createElement("div");
          div.className = "cell" + (board[y][x] ? " filled" : "");
          div.dataset.x = x;
          div.dataset.y = y;

          div.addEventListener("mouseenter", onCellHover);
          div.addEventListener("mousemove", onCellHover);
          div.addEventListener("click", onCellClick);

          boardEl.appendChild(div);
        }
      }
    }

    function randomShape() {
      const idx = Math.floor(Math.random() * SHAPES.length);
      return JSON.parse(JSON.stringify(SHAPES[idx]));
    }

    function newPieceSet() {
      pieces = [
        { shape: randomShape(), used: false },
        { shape: randomShape(), used: false },
        { shape: randomShape(), used: false },
      ];
      selectedPieceIndex = null;
      dragPieceIndex = null;
      isDragging = false;
      hoverX = hoverY = null;
      clearHighlights();
      renderPieces();
      turnInfoEl.textContent = "新しいセット";
    }

    
    function createDragGhost(piece, clientX, clientY) {
      if (!piece) return;
      if (dragGhostEl) {
        dragGhostEl.remove();
        dragGhostEl = null;
      }
      const ghost = document.createElement("div");
      ghost.className = "drag-ghost";

      const grid = document.createElement("div");
      grid.className = "piece-grid";

      const cells = new Set(piece.shape.cells.map(([x, y]) => `${x},${y}`));
      for (let yy = 0; yy < 5; yy++) {
        for (let xx = 0; xx < 5; xx++) {
          const c = document.createElement("div");
          c.className = "p-cell";
          if (cells.has(`${xx},${yy}`)) c.classList.add("filled");
          grid.appendChild(c);
        }
      }

      ghost.appendChild(grid);
      document.body.appendChild(ghost);
      dragGhostEl = ghost;
      updateDragGhostPosition(clientX, clientY);
    }

    function updateDragGhostPosition(clientX, clientY) {
      if (!dragGhostEl) return;
      dragGhostEl.style.left = clientX + "px";
      dragGhostEl.style.top  = clientY + "px";
    }

    function removeDragGhost() {
      if (dragGhostEl) {
        dragGhostEl.remove();
        dragGhostEl = null;
      }
    }

function renderPieces() {
      piecesEl.innerHTML = "";
      pieces.forEach((p, idx) => {
        const wrapper = document.createElement("div");
        wrapper.className = "piece";
        if (p.used) wrapper.classList.add("disabled");
        if (idx === selectedPieceIndex && !p.used) wrapper.classList.add("selected");

        wrapper.addEventListener("mousedown", (e) => {
          e.preventDefault();
          if (p.used || gameOver) return;
          selectedPieceIndex = idx;
          dragPieceIndex = idx;
          isDragging = true;
          hoverX = hoverY = null;
          clearHighlights();
          const rect = wrapper.getBoundingClientRect();
          const cx = e.clientX;
          const cy = e.clientY;
          createDragGhost(p, cx, cy);
          renderPieces();
          statusEl.textContent = "盤面にドラッグしてドロップしてください。";
        });

        wrapper.addEventListener("touchstart", (e) => {
          if (p.used || gameOver) return;
          const t = e.touches[0];
          selectedPieceIndex = idx;
          dragPieceIndex = idx;
          isDragging = true;
          hoverX = hoverY = null;
          clearHighlights();
          if (t) {
            createDragGhost(p, t.clientX, t.clientY);
          }
          renderPieces();
          statusEl.textContent = "盤面にドラッグしてドロップしてください。";
        }, { passive: true });

        const grid = document.createElement("div");
        grid.className = "piece-grid";

        const cells = new Set(p.shape.cells.map(([x,y]) => `${x},${y}`));
        for (let yy = 0; yy < 5; yy++) {
          for (let xx = 0; xx < 5; xx++) {
            const c = document.createElement("div");
            c.className = "p-cell";
            if (cells.has(`${xx},${yy}`)) c.classList.add("filled");
            grid.appendChild(c);
          }
        }

        wrapper.appendChild(grid);
        piecesEl.appendChild(wrapper);
      });
    }

    function canPlace(shape, bx, by) {
      for (const [sx, sy] of shape.cells) {
        const x = bx + sx;
        const y = by + sy;
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return false;
        if (board[y][x]) return false;
      }
      return true;
    }

    function placeShape(shape, bx, by) {
      let cellsPlaced = 0;
      for (const [sx, sy] of shape.cells) {
        const x = bx + sx;
        const y = by + sy;
        board[y][x] = 1;
        cellsPlaced++;
      }
      return cellsPlaced;
    }

    function checkLinesAndClear() {
      const fullRows = [];
      const fullCols = [];

      for (let y = 0; y < BOARD_SIZE; y++) {
        if (board[y].every(v => v === 1)) fullRows.push(y);
      }
      for (let x = 0; x < BOARD_SIZE; x++) {
        let ok = true;
        for (let y = 0; y < BOARD_SIZE; y++) {
          if (!board[y][x]) { ok = false; break; }
        }
        if (ok) fullCols.push(x);
      }

      const linesCleared = fullRows.length + fullCols.length;

      for (const y of fullRows) {
        for (let x = 0; x < BOARD_SIZE; x++) board[y][x] = 0;
      }
      for (const x of fullCols) {
        for (let y = 0; y < BOARD_SIZE; y++) board[y][x] = 0;
      }

      return linesCleared;
    }

    function updateStats() {
      scoreEl.textContent = score;
      comboEl.textContent = currentCombo;
      maxComboEl.textContent = maxCombo;
      blocksPlacedEl.textContent = blocksPlaced;
    }

    function anyMovesLeft() {
      for (const p of pieces) {
        if (p.used) continue;
        const shape = p.shape;
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (canPlace(shape, x, y)) return true;
          }
        }
      }
      return false;
    }

    function playLineSE(linesCleared) {
      try {
        if (linesCleared <= 0) return;
        if (linesCleared === 1) {
          se1.currentTime = 0;
          se1.play();
        } else if (linesCleared === 2) {
          se2.currentTime = 0;
          se2.play();
        } else {
          se3.currentTime = 0;
          se3.play();
        }
      } catch (e) {
        console.warn("SE error", e);
      }
    }

    function handleGameOver() {
      if (gameOver) return;
      gameOver = true;

      const bonus = maxCombo * 5;
      score += bonus;
      updateStats();

      statusEl.textContent = `ゲームオーバー！最大コンボボーナス +${bonus}pt を加算しました。`;
      log(`<strong>ゲーム終了</strong>：最大コンボ ${maxCombo} ×5 = +${bonus}pt、最終スコア ${score}`);

      try {
        seGameover.currentTime = 0;
        seGameover.play();
      } catch (e) {
        console.warn("gameover SE error", e);
      }

      // ★ ミニゲームサイトのスコア送信（gameId = "block"）
      submitScore("block", score, {
            maxCombo,
            blocksPlaced
          }).catch((err) => {
            console.warn("submitScore(block) failed:", err);
          });
    }

    function clearHighlights() {
      document.querySelectorAll(".cell").forEach(c => {
        c.classList.remove("highlight", "invalid");
      });
    }

    function highlightShape(shape, bx, by) {
      clearHighlights();
      const valid = canPlace(shape, bx, by);
      for (const [sx, sy] of shape.cells) {
        const x = bx + sx;
        const y = by + sy;
        const selector = `.cell[data-x="${x}"][data-y="${y}"]`;
        const cell = document.querySelector(selector);
        if (!cell) continue;
        if (valid) cell.classList.add("highlight");
        else cell.classList.add("invalid");
      }
    }

    function onCellHover(e) {
      if (!isDragging || dragPieceIndex === null || gameOver) return;
      const piece = pieces[dragPieceIndex];
      if (!piece || piece.used) return;

      const x = parseInt(e.currentTarget.dataset.x, 10);
      const y = parseInt(e.currentTarget.dataset.y, 10);

      hoverX = x;
      hoverY = y;

      highlightShape(piece.shape, x, y);
    }

    // スマホ用：タッチ座標から hoverX / hoverY を計算
    function onBoardTouchMove(e) {
      if (!isDragging || dragPieceIndex === null || gameOver) return;
      const piece = pieces[dragPieceIndex];
      if (!piece || piece.used) return;
      const touch = e.touches[0];
      if (!touch) return;

      const rect = boardEl.getBoundingClientRect();
      const relX = touch.clientX - rect.left;
      const relY = touch.clientY - rect.top;
      const nx = Math.floor(relX / rect.width * BOARD_SIZE);
      const ny = Math.floor(relY / rect.height * BOARD_SIZE);

      if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
        hoverX = hoverY = null;
        clearHighlights();
        return;
      }
      hoverX = nx;
      hoverY = ny;
      highlightShape(piece.shape, nx, ny);
      e.preventDefault();
    }

    function doPlace(shape, piece, px, py) {
      const cellsPlaced = placeShape(shape, px, py);
      piece.used = true;
      blocksPlaced++;

      // 置いた瞬間のSE
      try {
        seMove.currentTime = 0;
        seMove.play();
      } catch (e) {
        console.warn("move SE error", e);
      }

      const linesCleared = checkLinesAndClear();

      let gained = 0;
      gained += cellsPlaced;

      let comboBonus = 0;
      if (linesCleared > 0) {
        gained += linesCleared * 10;
        currentCombo = linesCleared;
        if (linesCleared >= 4) comboBonus = 30;
        else if (linesCleared === 3) comboBonus = 20;
        else if (linesCleared === 2) comboBonus = 10;
        gained += comboBonus;

        if (currentCombo > maxCombo) maxCombo = currentCombo;
        log(`ライン消去：${linesCleared}本 同時に消去（コンボボーナス +${comboBonus}）`);

        playLineSE(linesCleared);
      } else {
        currentCombo = 0;
      }

      score += gained;
      updateStats();
      renderBoard();
      renderPieces();

      turnInfoEl.textContent = pieces.every(p => p.used)
        ? "セット完了 → 自動で次のセットが出ます"
        : "あと " + pieces.filter(p => !p.used).length + " ピース";

      log(`ブロック配置：マス数${cellsPlaced} → この手 +${gained}pt（合計 ${score}pt）`);

      if (pieces.every(p => p.used)) {
        newPieceSet();
        renderBoard();
      }

      if (!anyMovesLeft()) {
        handleGameOver();
      } else {
        statusEl.textContent = "続けてブロックをドラッグ or タップで配置してください。";
      }
    }

    function endDragAndMaybePlace() {
      if (!isDragging || dragPieceIndex === null || gameOver) {
        isDragging = false;
        dragPieceIndex = null;
        hoverX = hoverY = null;
        clearHighlights();
        removeDragGhost();
        return;
      }
      const piece = pieces[dragPieceIndex];
      if (!piece || piece.used || hoverX === null || hoverY === null) {
        isDragging = false;
        dragPieceIndex = null;
        hoverX = hoverY = null;
        clearHighlights();
        removeDragGhost();
        return;
      }

      const shape = piece.shape;
      const bx = hoverX;
      const by = hoverY;

      if (!canPlace(shape, bx, by)) {
        statusEl.textContent = "そこには置けません。別の場所を試してください。";
        isDragging = false;
        dragPieceIndex = null;
        hoverX = hoverY = null;
        clearHighlights();
        removeDragGhost();
        return;
      }

      doPlace(shape, piece, bx, by);

      selectedPieceIndex = null;
      dragPieceIndex = null;
      isDragging = false;
      hoverX = hoverY = null;
      clearHighlights();
      removeDragGhost();
    }

    function onCellClick(e) {
      if (gameOver) return;

      const x = parseInt(e.currentTarget.dataset.x, 10);
      const y = parseInt(e.currentTarget.dataset.y, 10);

      const idx = (dragPieceIndex !== null ? dragPieceIndex : selectedPieceIndex);
      if (idx === null) {
        statusEl.textContent = "先にブロックを選択（またはドラッグ開始）してください。";
        return;
      }
      const piece = pieces[idx];
      if (!piece || piece.used) return;

      const shape = piece.shape;
      const bx = hoverX !== null && hoverY !== null ? hoverX : x;
      const by = hoverY !== null ? hoverY : y;

      if (!canPlace(shape, bx, by)) {
        statusEl.textContent = "そこには置けません。別の場所を試してください。";
        return;
      }

      doPlace(shape, piece, bx, by);

      selectedPieceIndex = null;
      dragPieceIndex = null;
      isDragging = false;
      hoverX = hoverY = null;
      clearHighlights();
    }

    function newGame() {
      initBoard();
      score = 0;
      currentCombo = 0;
      maxCombo = 0;
      blocksPlaced = 0;
      gameOver = false;
      logEl.innerHTML = "";
      log("<strong>新しいゲーム開始！</strong>");
      newPieceSet();
      renderBoard();
      updateStats();
      statusEl.textContent = "ブロックをドラッグして、盤面にドロップしてください。（タップ置きも可）";
    }

    document.addEventListener("DOMContentLoaded", () => {
      boardEl = document.getElementById("board");
      piecesEl = document.getElementById("pieces");
      logEl = document.getElementById("log");
      scoreEl = document.getElementById("score");
      comboEl = document.getElementById("combo");
      maxComboEl = document.getElementById("maxCombo");
      blocksPlacedEl = document.getElementById("blocksPlaced");
      statusEl = document.getElementById("statusText");
      turnInfoEl = document.getElementById("turnInfo");

      seMove = document.getElementById("seMove");
      se1 = document.getElementById("se1");
      se2 = document.getElementById("se2");
      se3 = document.getElementById("se3");
      seGameover = document.getElementById("seGameover");

      document.getElementById("newGame").addEventListener("click", newGame);

      boardEl.addEventListener("touchmove", onBoardTouchMove, { passive: false });
      boardEl.addEventListener("touchstart", onBoardTouchMove, { passive: false });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging || !dragGhostEl) return;
        updateDragGhostPosition(e.clientX, e.clientY);
      });

      document.addEventListener("touchmove", (e) => {
        if (!isDragging || !dragGhostEl) return;
        const t = e.touches[0];
        if (!t) return;
        updateDragGhostPosition(t.clientX, t.clientY);
      }, { passive: false });

      document.addEventListener("mouseup", () => {
        endDragAndMaybePlace();
      });
      document.addEventListener("touchend", () => {
        endDragAndMaybePlace();
      });

      newGame();
    });
  </script>

  <!-- 必要ならここで共通JS（submitScore定義など）を読み込み -->
  <!-- </body>
</html>
