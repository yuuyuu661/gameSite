<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>スロット</title>
<link rel="stylesheet" href="../../assets/css/styles.css" />
<script type="module">
  import { renderHeader } from "../../common/header.js";
  import { points } from "../../assets/js/portal.js";
  points.ensureInit(1000);
  renderHeader({ title: "スロット", backTo: "../../index.html" });
  window.addEventListener("DOMContentLoaded", () => {
    const frame = document.getElementById("slot-frame");
    const params = new URLSearchParams({ session: "DEMO_LOCAL", coins: String(points.get()) });
    frame.src = `./original/slot-main/public/index.html?${params.toString()}`;
  });
</script>
<style>
  html, body { height: 100%; }
  body { margin: 0; overflow: hidden; }
  .frame-holder {
    position: relative; height: 100dvh; padding-top: 56px;
    display: grid; place-items: center; background: #0a0f1c;
  }
  .frame-holder iframe {
    width: min(100vw, 900px); height: calc(100dvh - 70px);
    border: 0; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); background:#000;
  }
  @media (min-width: 1024px) {
    .frame-holder iframe { width: min(96vw, 1100px); height: calc(100vh - 80px); }
  }
</style>
</head>
<body>
  <div class="frame-holder">
    <iframe id="slot-frame" src="" title="slot" allowfullscreen></iframe>
  </div>
  <script type="module">
    import { points } from "../../assets/js/portal.js";
    const frame = document.getElementById("slot-frame");
    function mockFetchInFrame(w) {
      const Response = w.Response;
      const headers = { "Content-Type": "application/json" };
      const ok = (obj) => Promise.resolve(new Response(JSON.stringify(obj), { status:200, headers }));
      const orig = w.fetch ? w.fetch.bind(w) : null;
      w.fetch = (input, init) => {
        const url = (typeof input === "string") ? input : (input && input.url) || "";
        if (/\/api\/session/i.test(url)) { return ok({ ok:true, session:"DEMO_LOCAL", coins: points.get() }); }
        if (/\/api\/(settle|payout|cashout)/i.test(url)) { return ok({ ok:true }); }
        return orig ? orig(input, init) : ok({ ok:true });
      };
    }
    function replaceTextDeep(node, from, to) {
      const walk = (n) => {
        if (n.nodeType === 3) { if (n.nodeValue && n.nodeValue.includes(from)) n.nodeValue = n.nodeValue.replaceAll(from, to); }
        else if (n.nodeType === 1) for (const c of Array.from(n.childNodes)) walk(c);
      };
      walk(node);
    }
    function hideSettlementButtons(d) {
      const btns = d.querySelectorAll('button, a, [role="button"], .btn, .button');
      for (const el of btns) { const t=(el.textContent||"").trim(); if (/(清算|換金|settle|cash\s*out|payout)/i.test(t)) el.style.display="none"; }
    }
    function syncBalance(d) {
      const current = points.get();
      const selectors = ['#coins','.coins','[data-coins]','#balance','.balance','[id*="coin"]','[class*="coin"]','[id*="point"]','[class*="point"]'];
      let updated=0;
      for (const sel of selectors) {
        for (const el of d.querySelectorAll(sel)) { if (el.children.length===0) { el.textContent=String(current); updated++; } }
        if (updated>0) break;
      }
      if (updated===0) {
        const labels = Array.from(d.querySelectorAll('*')).filter(el => el.children.length===0);
        for (const el of labels) {
          const t=(el.textContent||"").trim();
          if (/所持point|所持ポイント|ポイント|point/i.test(t)) {
            const next = el.nextElementSibling;
            if (next && next.children.length===0) { next.textContent=String(current); break; }
          }
        }
      }
    }
    function patchFrame() {
      try {
        const w = frame.contentWindow;
        const d = frame.contentDocument;
        if(!w||!d) return;
        mockFetchInFrame(w);
        replaceTextDeep(d.body, "所持コイン", "所持point");
        hideSettlementButtons(d);
        syncBalance(d);
        window.addEventListener("points:change", () => syncBalance(d));
        // Allow game to adjust wallet via postMessage
        w.addEventListener("message", (ev) => {
          const data = ev.data;
          if (data && data.type==="arcade:addPoints" && Number.isFinite(+data.delta)) points.add(+data.delta);
        });
      } catch(e) { console.warn("patch error", e); }
    }
    frame.addEventListener("load", () => setTimeout(patchFrame, 150));
  </script>
</body>
</html>
